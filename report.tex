% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt,twocolumn]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options
\usepackage{mathtools}
\usepackage{amsmath} % need this stuff for curly brackets
% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

\title{Software Engineering For Industry \\ Coursework 2 - Report}
\author{Dan Demeter, Dan Octavian, Razvan Rosie, Marius Telespan \\Imperial College London}

\begin{document}
\maketitle

\begin{abstract}
Write this at the very end. It must respond to questions like:

Keywords:
\end{abstract}

\pagebreak

\section{Introduction}
Here comes the intro..

\section{ACME Telecom v2}

\subsection{Improved Cost Calculator}

The old implementation for calculating the call costs was not taking correctly into consideration 
the starting and end times for a call. As a results, calls which were taking place during both off-peak and 
on-peak times were being charged for the entire duration with the on-peak tariff. For example, for an on-peak
period of 7:00 - 18:59, a call from 20:30 till 21:30 would be correctly charged for 60 minutes $\ast$
off-peak tariff, but a call from  18:30 till 19:30 would be charged incorrectly 60 minutes $\ast$ \textbf{on-peak},
instead of 30 minutes $\ast$ \textbf{on-peak} $+$ 30 minutes $\ast$ \textbf{off-peak}.

Our code implementation solves this problem, and the algorithm is as follows. All notations represented by big letters 
are DateTime instances:

1) For the start call ( START ), find the next peak time start or end time ( 7:00 or 18:59 ) and save it as T1;

2) Next, find the last start or end on-peak time that is before the end call ( END ) and save it as T2;
The case when START and LAST times are in the same peak or off-peak period is the trivial one: we compute the 
cost for the call as (LAST - START) $\ast$ (on-peak OR off-peak) tariff. The tariff type can be easily found. 

In the other case when START and LAST times are in different zones, we calculate how many 12 hours intervals are between T1 and T2.
If that number is even, then we know that the phone call lasted $\leq$ 24 hours. So we know that 1/2 of that time the call should be 
charged with the offpeak tariff, and the other 1/2 time should be charged with the on-peak time. 
In case that number is odd, then we identify the one extra period and which tariff should be applied to it, and then for the rest of the 
even periods, we apply the tactic discussed above. 

In the end, the final cost is the total cost for the 12 hours periods + (the cost between START and T1 (C1)) + (the cost between T2 and END (C2). 
Again, for C1 and C2 we can easily identify what tariff we need to use (peak or off-peak one).

Also, JodaTime helped us a lot in order to manage all the complexity for handling periods of time,
translating the a date into milliseconds and subtracting 2 different Dates. 

\subsection{Output Interfaces}

In terms of generating the status of the bills for the customers, the system was directing its results to the Standard Output pipe. 
Unfortunately, the only output interface (HtmlPrinter) was generating HTML tables which were not following the W3C standards. 
Because we have decided to make our system as reliable as possible, we had to take into consideration different set-ups where our system would be running. 
For example, it could run on a server without any output attached (headless server), or for debugging purposes, 
the billing output should be easily read and p arsed from the terminal. 
By using the abstract factory design pattern, we have restructured our Output Interface as an abstract Class, 
having different classes extend it. These classes will be actual printing and formatting the results in a way suitable for the environment.
The current classes we have implemented or changed in the system are: HTMLPrinter and ConsolePrinter. HTMLPrinter is the initial implementation 
of printing the results in an HTML format. We have decided \textbf{not} to change it, because some other legacy software might be parsing the
HTML file generated by our system. This is a major risk, because we can't control what other software interacts with the current one.

Instead, for 100\% legacy compatibility, we have decided to add new Classes extending the Output Interface. 
The first one we have added is the ConsolePrinter class that is used to print the BillingSystem output in a readable format used for debugging.
This is what we have used to test our product, integrating the ConsolePrinter with the Tests we ran. Also, because mostly all new systems will be used 
part of a bigger architecture, we have decided to implement an API interface, used for our system to export its data to others systems. 




\section{Code improvement}

\subsection{Handling the cyclic dependencies}
This was caused by an inner LineItem class within BillingSystem. This was required by
BillGenerator, as it was populating a data structure containing all phone calls made by
customers.
To solve this, LineItem was extracted out into the com.acmetelecom.util subpackage,
thus removing this cyclic dependency, and at the same time, evolving the overall system
towards a more reasonable structure.

\subsection{Code refurbishment}
The existing codebase was restructured to become increasingly modular. By applying con-
cepts of dependency inversion and abstraction, we decoupled these classes into packages,
each with a dedicated purpose.
This brought about many benefits, such as encouraging code reuse and making testing
convenient. Our team could now work simultaneously and asynchronously. Integration
would be almost painless, due to a clear separation of concerns, introduced by interfaces.
Ease of collaboration was also an added benefit.
Full details of external dependencies as well as an architecture diagram, are available for reference.
The project was managed using Maven, where external dependencies are specified as
artifacts in pom.xml. The main application and test code are housed in distinct subfolders,
yet test code is able to reference the Class Under Test (CUT). Test code is also composed
as hierarchical TestSuites, to selectively test different segments of the codebase. Hardcoded
constants belong in a properties file, in the respective resources folder.





\section{Extra Work}

\subsection{Source code validation}
Another important aspect of software engineering is source code validation. Besides the
aforementioned high level dependency analysis, it is probably worth using tools like Lint4J
and CodePro AnalytiX to audit code, produce metrics, such as Afferent/Efferent Coup-
lings, to measure code quality, and find similar/dead code to identify and remove redund-
ancy, hence streamlining the codebase, in preparation for deployment to target environ-
ment.

\subsection{Testing}
Testing was further augmented by importing techniques used in web applications for ex-
ample, like the Selenium web browser automated testing tool, and JSoup to construct
HTML parse trees, and navigate through them using combinations of familiar jQuery-like
selectors, for better code coverage, and hence greater confidence in the final end product.

\subsection{Documentation}
On top of the builtin javadoc tool, the JAutodoc tool was used to generate Java documentation of typical classes like the model CustomerBill for completeness.
Subsequently, additional configuration enabled styling of the resulting generated Javadocs

\subsection{Calls Longer than 24 Hours}
Calculating calls longer than 24 hours become simpler once the FairPeakCalculator was
completed, because these calls are but just multiples of calls lasting a full day with some
leftover. The cost for this remaining part of the call can be calculated using the original
FairPeakCalculator, then added together for the final result, according to the expression:
total peak seconds in a day * peak rate + total offpeak seconds in a day * offpeak rate

\section{Software Engineering stuff}
here comes some stuff

\section{Conclusion}
In conclusion, our prohect have demonstrated in this project how to go about engineering software
with a long term vision, using proper procedures, with proven techniques and tools, which
are still applicable as the software system scales as it matures over time.
From the traditional tools for any project, such as a version control system like Git, bug
or issue tracking system like Trac, and continuous integration service like TeamCity, to
the extensive suite of testing tools for supporting through the various stages of testing,
namely, Acceptance, Unit, Integration, System, and Regression, there is evidently more
that can still be done to improve this software, given sufficient resources.

For example, the code obsfucation and optimisation Java tool, ProGuard, can also be used
during live deployment, to increase the code efficiency. If resources permit, we might have
also explored other alternatives for mocking up Java objects, like jMock, EasyMock or
Mockito frameworks, as well as other acceptance testing frameworks like JBehave.
Or even further optimise our code by profiling using VisualVM, and substituting commonly
used functions for those found in the Apache Commons project, or the Google Guava
libraries, which are far more widely used or tested, thus more reliable. There could also be
the possibility to attempt dependency injection using Google Guice, to improve testability
of, and simplify deployment across different production environments.

\pagebreak


\begin{thebibliography}{9}

\bibitem{lamport94}
  Leslie Lamport,
  \emph{\LaTeX: A Document Preparation System}.
  Addison Wesley, Massachusetts,
  2nd Edition,
  1994.

\end{thebibliography}




\end{document}          
